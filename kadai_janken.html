<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>じゃんけん課題</title>
    <style>
        body {
            margin: 30px;
            padding: 0;
            color: #000;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0 15px 0;
        }

        h1 {
            color: gray;
        }

        h2 {
            color: #4169e1;
        }

        h3 {
            color: #00ff00;
        }

        h4 {
            color: #dc143c;
        }

        h5 {
            color: #4b0082;
        }

        h6 {
            color: #009688;
        }

        a {
            color: #0000cd;
        }

        hr {
            border: 1px solid #ff00ff;
        }

        div.topad {
            margin-top: 50px !important;
            text-align: center;
        }

        h1 {
            font-size: 2rem;
            line-height: 1.5;
        }

        h2 {
            font-size: 1.4rem;
            line-height: 1.4;
            margin-left: 1em;
        }

        h3 {
            font-size: 1.3rem;
            line-height: 1.3;
            margin-left: 2em;
        }

        h4 {
            font-size: 1.2rem;
            line-height: 1.2;
            margin-left: 3em;
        }

        h5 {
            font-size: 1.1rem;
            line-height: 1.1;
            margin-left: 4em;
        }

        h6 {
            font-size: 1.0rem;
            line-height: 1.0;
            margin-left: 5em;
        }

        h1~a {
            margin-left: 1em;
        }

        h2~a {
            margin-left: 2em;
        }

        h3~a {
            margin-left: 3em;
        }

        h4~a {
            margin-left: 4em;
        }

        h5~a {
            margin-left: 5em;
        }

        h6~a {
            margin-left: 6em;
        }

        h1~div {
            margin-left: 1em;
        }

        h2~div {
            margin-left: 2em;
        }

        h3~div {
            margin-left: 3em;
        }

        h4~div {
            margin-left: 4em;
        }

        h5~div {
            margin-left: 5em;
        }

        h6~div {
            margin-left: 6em;
        }
    </style>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script>

        //ランダムで何を出すか決める
        const randomnumber1 = Math.random();
        const randomnumber2 = Math.floor(randomnumber1 * 3);
        console.log(randomnumber2);

        if (randomnumber2 === 0) { //0の時グー

            function onInit() {
                blockImagePaths = new Array('url(img/gu.jpg)', 'url(img/ex_img.jpg)');
            }
            console.log("gu")
        }
        else if (randomnumber2 === 1) { //1のときチョキ
            function onInit() {
                blockImagePaths = new Array('url(img/choki.jpg)', 'url(img/ex_img.jpg)');
                gameoverMessage = '';
            }
            console.log("cho")
        }
        else if (randomnumber2 === 2) { //2のときパー
            function onInit() {
                blockImagePaths = new Array('url(img/pa.jpg)', 'url(img/ex_img.jpg)');
                gameoverMessage = '';
            }
            console.log("pa")
        }






    </script>



    <link rel="stylesheet" href="kadai.css">

</head>

<body>

    <!--回答ボタン------------------------------------------------------------------->
    <button class="button_gu" id="button_gu">グーを出す</button>
    <button class="button_cho" id="button_cho">チョキを出す</button>
    <button class="button_pa" id="button_pa">パーを出す</button>

    <!--ストップウォッチボタン-->
    <p><button id="start">開始/リセット</button><button id="pause">一時停止/再開</button><button id="wrap">ラップ</button></p>
    <p id="watchArea"></p>
    <textarea id="wrapArea"></textarea>

    <script>


        window.addEventListener("DOMContentLoaded", () => {
            /**
             * @param watchCallBack 経過時間報告用コールバック
             * @param wrapCallBack ラップ報告用コールバック
             */
            const getStopWatch = function (watchCallBack, wrapCallBack) {
                let accumulatedTime = 0,    // 積算時間
                    currentTime = null,       // タイマー開示タイムスタンプ
                    timerId = null;           // setInterval() の返り値

                // リセット処理
                const reset = () => {
                    timerOff(); accumulatedTime = 0; currentTime = null;
                    // リセットされたことをnullで通知
                    watchCallBack(null); wrapCallBack(null);
                };
                // 開始処理
                const start = () => { currentTime = Date.now(); timerOn(); };
                // 一時停止処理
                const pause = () => {
                    // これまでの経過時間を退避
                    accumulatedTime = getNowTime();
                    timerOff();
                    currentTime = null;
                };
                // 再開処理
                const resume = () => start();
                // ラップ報告処理
                const wrap = () => wrapCallBack(getNowTime());
                // 経過時間の算出
                const getNowTime = () => accumulatedTime + Date.now() - currentTime;

                // タイマー停止処理
                const timerOff = () => {
                    if (timerId === null) return;
                    clearInterval(timerId);
                    timerId = null;
                };
                // タイマー開始処理
                const timerOn = () => {
                    if (timerId !== null) clearTimeout(timerId);
                    timerId = setInterval(() => watchCallBack(getNowTime()), 10);
                };

                reset();

                // 必要な機能だけ返す
                return Object.freeze({
                    start: () => currentTime === null && accumulatedTime === 0 ? start() : reset(),
                    pause: () => currentTime === null ? (accumulatedTime === 0 ? false : resume()) : pause(),
                    wrap: () => currentTime === null ? false : wrap(),
                });
            };

            // ミリ秒を画面表示する形式に変換
            const timeString = time => `${Math.floor(time / 60000).toString().padStart(2, "00")
                }:${Math.floor(time % 60000 / 1000).toString().padStart(2, "00")
                }.${Math.floor(time % 1000).toString().padStart(3, "000").slice(0, 2)
                }`;

            const watchArea = document.getElementById("watchArea");
            const wrapArea = document.getElementById("wrapArea");

            const stopWatchObj = getStopWatch(
                time => watchArea.textContent = time === null ? "00:00.00" : timeString(time),
                time => wrapArea.value = time === null ? "" : wrapArea.value + "\n" + timeString(time)
            );

            const buttonDefine = [
                { id: "start", listener: () => stopWatchObj.start() },
                { id: "pause", listener: () => stopWatchObj.pause() },
                { id: "wrap", listener: () => stopWatchObj.wrap() }
            ];
            buttonDefine.forEach(e => document.getElementById(e.id).addEventListener("click", e.listener));
        });




        /*ボタンの挙動*/
        /*グーだったときの挙動*/
        if (randomnumber2 === 0) {
            $('#button_gu').on('click', function () {
                alert("あいこでした");
            });

            $('#button_cho').on('click', function () {
                alert("負けでした");
            });

            $('#button_pa').on('click', function () {
                alert("勝ち！賞金があります！");
                location.href = 'kadai_janken_win.html';

            });
        }

        /*チョキだったときの挙動*/
        if (randomnumber2 === 1) {
            $('#button_gu').on('click', function () {
                alert("勝ち！賞金があります！");
                location.href = 'kadai_janken_win.html';

            });

            $('#button_cho').on('click', function () {
                alert("あいこでした");
            });

            $('#button_pa').on('click', function () {
                alert("負けでした");

            });
        }


        /*パーだったときの挙動*/
        if (randomnumber2 === 2) {
            $('#button_gu').on('click', function () {
                alert("負けでした");
            });

            $('#button_cho').on('click', function () {
                alert("勝ち！賞金があります！");
                location.href = 'kadai_janken_win.html';

            });

            $('#button_pa').on('click', function () {
                alert("あいこでした");

            });
        }


        /*ボタンの挙動終わり*--------------------------------------------------------/






        /*---------------------------------------------------------------------------
        JavaScriptブロック崩しライブラリblock.js
 
        使い方
        ------
        HTMLファイルを作成し、headタグ内に以下のように書いてください。
 
        <script type="text/javascript" src="block.js">
        
        bodyタグには何も書かなくておｋ。
        このタグより前にJavaScriptでonInitという関数を定義しておくと、初期化前に読み込まれます。onInitの中で設定変数を変更することができます。block.js自身を書き換える必要はありません。
        
        
        Copyright (c) 2010 recyclebin5385 All rights reserved.
        
        ソースコード形式かバイナリ形式か、変更するかしないかを問わず、以下の条件を満たす場合に限り、再頒布および使用が許可されます。
        
        * ソースコードを再頒布する場合、上記の著作権表示、本条件一覧、および下記免責条項を含めること。
        * バイナリ形式で再頒布する場合、頒布物に付属のドキュメント等の資料に、上記の著作権表示、本条件一覧、および下記免責条項を含めること。
        * 書面による特別の許可なしに、本ソフトウェアから派生した製品の宣伝または販売促進に、作者の名前またはコントリビューターの名前を使用してはならない。
        
        本ソフトウェアは、著作権者およびコントリビューターによって「現状のまま」提供されており、明示黙示を問わず、商業的な使用可能性、および特定の目的に対する適合性に関する暗黙の保証も含め、またそれに限定されない、いかなる保証もありません。著作権者もコントリビューターも、事由のいかんを問わず、損害発生の原因いかんを問わず、かつ責任の根拠が契約であるか厳格責任であるか（過失その他の）不法行為であるかを問わず、仮にそのような損害が発生する可能性を知らされていたとしても、本ソフトウェアの使用によって発生した（代替品または代用サービスの調達、使用の喪失、データの喪失、利益の喪失、業務の中断も含め、またそれに限定されない）直接損害、間接損害、偶発的な損害、特別損害、懲罰的損害、または結果損害について、一切責任を負わないものとします。
        */

        //定数
        var PHASE_START = 0;
        var PHASE_PLAYING = 1;
        var PHASE_GAMEOVER = 2;
        var PHASE_CLEAR = 3;

        //設定変数
        var stageHeight = 420; //ステージの高さ
        var backgroundColor = '#CCFFFF'; //ステージの背景色
        var backgroundMarginLeft = 300; //ステージの左の余白
        var backgroundMarginTop = 50; //ステージの上の余白
        var backgroundMarginRight = 100; //ステージの右の余白
        var backgroundMarginBottom = 50; //ステージの下の余白

        var blockLeft = 0; //ステージ左右端からブロックまでの余白
        var blockTop = 0; //ステージ上端からブロックまでの余白
        var blockCountX = 8; //横方向のブロック数
        var blockCountY = 8; //縦方向のブロック数
        var blockWidth = 50; //ブロック1つの幅
        var blockHeight = 30; //ブロック1つの高さ
        var blockColors = new Array('transparent', '#9999ff'); //第2引数 … 薄紫色。ライフごとのブロックの色。画像適用しているので見た目上は関係がない
        var blockImagePaths = new Array('', ''); //ライフごとのブロックの画像のパス。["", ""]


        var barY = 400; //バー上端座標
        var barWidth = 50; //バー幅
        var barHeight = 10; //バー高さ
        var barColor = '#cc6633'; //バーの色

        var ballRadius = 2; //ボールの半径
        var ballColor = '#ff0000'; //ボールの色。赤色
        var penetrateBallColor = '#FF9900'; //貫通弾の色。黄色

        var messageColor = '#ffff00'; //メッセージの色
        var messageFontSize = '150%'; //メッセージのサイズ

        var maxLife = 3; //プレイヤーの最大ライフ
        var penetrateRegionWidth = 2; //打ち返すと貫通弾となる領域の幅
        var maxClearMessageCount = 100; //クリアのメッセージが消えるまでのカウント

        //var initialBlockLives = null; //ブロックのライフの初期値の配列　nullならぜんぶ1
        var initialBlockLives = null; //ブロックのライフの初期値の配列　nullならぜんぶ1

        var startMessage = 'LIFE: ${life} Click to start';
        var gameoverMessage = 'GAME OVER';
        var clearMessage = 'congratulations';


        //制御変数
        var stageWidth; //ステージ幅 blockLeft, blockCountX, blockWidthから自動計算

        var oldBarX; //1フレーム前のバー左端座標
        var barX; //バー左端座標
        var ballX; //ボールのX座標
        var ballY; //ボールのY座標
        var ballDX; //ボールのX方向の変位
        var ballDY; //ボールのY方向の変位

        var blockLives; //ブロックのライフの配列

        var backgroundElement; //背景の要素
        var BarElement; //バーの要素
        var blockElements; //ブロックの要素の配列
        var ballElement; //ボールの要素
        var messageElement; //メッセージの要素

        var life; //プレイヤーのライフ
        var blockCount; //残っているブロックの数

        var phase = 'start'; //フェーズ

        var penetrateFlag = false; //貫通フラグ
        var lastHitBlockIndex; //最後に当たったブロックのインデックス
        var maxClearMessageCount; //クリアのメッセージが消えるまでのフレーム数

        var timerID; //タイマーのID

        //初期化関数
        function init() {
            if (typeof onInit == 'function') { //設定変数を変更するonInit関数を定義していれば、初期化前に読込
                onInit();
            }


            //座標の決定
            stageWidth = blockLeft * 2 + blockWidth * blockCountX; //0*2 + 50*8
            oldBarX = barX = (stageWidth - barWidth) / 2; //1フレーム前のバー左端座標 = バー左端座標 = (ステージ幅 - バー幅) / 2;


            //HTML要素の配置
            backgroundElement = document.createElement('div');
            backgroundElement.style.position = 'absolute';
            backgroundElement.style.left = 0;
            backgroundElement.style.top = 0;
            backgroundElement.style.marginLeft = backgroundMarginLeft + 'px';
            backgroundElement.style.marginTop = backgroundMarginTop + 'px';
            backgroundElement.style.marginRight = backgroundMarginRight + 'px';
            backgroundElement.style.marginBottom = backgroundMarginBottom + 'px';
            backgroundElement.style.width = stageWidth + 'px';
            backgroundElement.style.height = backgroundElement.style.lineHeight = stageHeight + 'px';
            backgroundElement.style.backgroundColor = backgroundColor;

            document.body.appendChild(backgroundElement);

            blockElements = new Array(blockCountX * blockCountY); //横方向のブロック数8 × 縦方向のブロック数8
            blockLives = new Array(blockCountX * blockCountY); //横方向のブロック数8 × 縦方向のブロック数8

            for (var j = 0; j < blockCountY; j++) { //縦方向のブロック数8 
                for (var i = 0; i < blockCountX; i++) { //横方向のブロック数8 var
                    blockElement = createElement(blockWidth, blockHeight, 'transparent'); //ブロック1つの幅50。ブロック1つの高さ30
                    blockElement.style.left = (blockLeft + i * blockWidth) + 'px'; //(0 + i * 50) 
                    blockElement.style.top = (blockTop + j * blockHeight) + 'px'; //(0 + j * 30) 
                    blockElement.style.backgroundPosition = (-i * blockWidth) + 'px ' + (-j * blockHeight) + 'px'; //(-i * 50) + 'px ' + (-j * 30) + 'px' 
                    blockElements[i + j * blockCountX] = blockElement;
                }
            }

            barElement = createElement(barWidth, barHeight, barColor);
            ballElement = createElement(ballRadius * 2, ballRadius * 2, ballColor);
            messageElement = createElement(stageWidth, stageHeight, 'transparent');
            messageElement.style.left = '0px';
            messageElement.style.top = '0px';
            messageElement.style.color = messageColor;
            messageElement.style.textAlign = 'center';
            messageElement.style.fontSize = messageFontSize;
            messageElement.innerHTML = '';
            messageElement.style.visibility = 'hidden';
            resetGame(); //ゲームリセット関数呼出 
            setObjectPosition(); //要素の表示位置設定関数呼出
            window.document.onmousemove = onMouseMove; //マウスを動かしたら、「マウス移動のイベントハンドラ」を呼ぶ
            window.document.onclick = onClick;

            setPhase(PHASE_START);
        }

        //クリックのイベントハンドラ。 
        function onClick(event) {

            //ゲーム開始とともにタイマー起動






            //複数ブラウザ対応用 
            if (window.event) {
                event = window.event;
            } if (event.button == 0) { //左クリック 
                switch (phase) {
                    case PHASE_START: setPhase(PHASE_PLAYING);
                        break; case PHASE_GAMEOVER: case PHASE_CLEAR: resetGame(); setPhase(PHASE_START); break; default: break;
                }
            }
        }
        //マウス移動のイベントハンドラ。 
        function onMouseMove(event) {
            //複数ブラウザ対応用 
            if (window.event) { //window.eventが取得できたら
                event = window.event; //変数eventの値をwindow.eventに置き換える 
            }  //window.eventがundefinedの場合、if文はfalse

            barX = document.body.scrollLeft + event.clientX - backgroundMarginLeft - barWidth / 2;//ウインドウの横スクロール座標(ブラウザ画面左からのスクロール量)(px) + 

            if (barX < 0) {  //マウスx座標が0はより小さくなったら。マウスがステージより左端へ移動したら
                barX = 0; //マウスx座標は0
            }

            if (stageWidth < barX + barWidth) {
                //「マウスx座標＋バー幅」がステージ幅を超えたら。マウスがステージより右端へ移動したら 
                barX = stageWidth - barWidth;

                //マウスx座標は、ステージ幅-バー幅
            }
            switch (phase) {
                case PHASE_START: ballX = barX + barWidth / 2; ballY = barY - ballRadius; break;
                default: break;
            }
            setObjectPosition();
        }

        //フェーズを設定する。 
        function setPhase(x) {
            phase = x; switch (phase) {
                case
                    PHASE_START: resetBall(); clearInterval(timerID); messageElement.style.visibility = 'visible';
                    messageElement.innerHTML = startMessage.replace('${life}', life);
                    break;
                case PHASE_PLAYING: timerID = setInterval(onTimer, 33); //タイマー起動 
                    messageElement.style.visibility = 'hidden';
                    break; case PHASE_GAMEOVER: clearInterval(timerID);
                    messageElement.style.visibility = 'visible';
                    ballElement.style.visibility = 'hidden';
                    messageElement.innerHTML = gameoverMessage;
                    break;
                case PHASE_CLEAR: clearMessageCount = maxClearMessageCount
                    messageElement.style.visibility = 'visible'; ballElement.style.visibility = 'hidden';
                    messageElement.innerHTML = clearMessage;
                    reak; default: break;

            } setObjectPosition();
        }

        //貫通フラグを切り替える。 
        function setPenetrateFlag(x) { penetrateFlag = x; ballElement.style.backgroundColor = x ? penetrateBallColor : ballColor; }

        //ボールの状態をリセットする 
        function resetBall() {
            ballElement.style.visibility = 'visible';
            ballX = barX + barWidth / 2; //ボールx位置… バ－X位置＋バーの長さ半分(バー中心) 
            ballY = barY - ballRadius;  //ボールY位置 … バーY位置 － ボール半径定数「2」 
            ballDX = -3; ballDY = -5;
            lastHitBlockIndex = null; setPenetrateFlag(false); //貫通フラグ切替関数呼出 
        }

        //ゲームをリセットする。 
        function resetGame() {
            life = maxLife;
            //プレイヤーの最大ライフ数 … 3 

            blockCount = blockCountX * blockCountY; //ステージエリア横方向配置ブロック数定数8 × ステージエリア縦方向配置ブロック数定数8 
            for (var i = 0;
                i < blockCount; i++) { //64 
                blockLives[i] = (initialBlockLives == null) ? 1 : initialBlockLives[i];//ブロックのライフの配列。ブロックのライフの初期値配列がnullなら1、それ以外ならinitialBlockLives配列にブロックの数を格納。initialBlockLivesは常にnullなので、ここは必ずTRUEになる。何のための条件分岐？
                //console.log(blockLives[i]); //ステージクリアしても常に1。どういう仕様？
                blockElements[i].style.backgroundImage = blockImagePaths[blockLives[i]]; //blockImagePaths[1];
                blockElements[i].style.backgroundColor = blockColors[blockLives[i]]; //blockColors[1];
            }

            resetBall();
        }

        //要素を作成し、背景の要素の子要素として登録する。
        function createElement(width, height, color) {
            var ret = document.createElement('div');
            ret.style.position = 'absolute'; ret.style.width = width + 'px';
            ret.style.height = ret.style.lineHeight = height + 'px';
            ret.style.backgroundColor = color; ret.style.fontSize = '0px';
            backgroundElement.appendChild(ret); return ret;
        }

        //要素の表示位置を設定する。 
        function setObjectPosition() {
            barElement.style.left = barX + 'px'; barElement.style.top = barY + 'px';
            ballElement.style.left = (ballX - ballRadius) + 'px';

            //ballRadius … ボール半径定数2 
            ballElement.style.top = (ballY - ballRadius) + 'px';
        }

        //ボールの位置にあるブロックのインデックスを返す。 
        function getBlockIndexAtBall() {
            if ((ballX < blockLeft) || (stageWidth - blockLeft < ballX)) {
                return null;
            }

            if ((ballY < blockTop) || (blockTop + blockHeight * blockCountY < ballY)) { //ブロック上Y位置＋各ブロック高さ×ステージエリア縦方向配置ブロック数定数8
                return null;
            }

            return Math.floor((ballX - blockLeft) / blockWidth) + Math.floor((ballY - blockTop) / blockHeight) * blockCountX;
        }

        //タイマーのイベントハンドラ。 
        function onTimer() {
            switch (phase) {
                case PHASE_PLAYING: onTimerPlaying();
                    break;
                case PHASE_CLEAR: onTimerClear();
                    break;
                default: break;
            }

        } function onTimerPlaying() {

            //X方向の移動 
            ballX += ballDX; var index = getBlockIndexAtBall();

            if ((index != null) && (blockLives[index] > 0) && (lastHitBlockIndex != index)) {
                blockLives[index]--;

                if (blockLives[index] == 0) {
                    blockCount--;
                }

                blockElements[index].style.backgroundImage = blockImagePaths[blockLives[index]];
                blockElements[index].style.backgroundColor = blockColors[blockLives[index]];

                if (!penetrateFlag) {
                    ballX -= ballDX;
                    ballDX = -ballDX;
                }
            }

            if ((ballX < 0) || (stageWidth < ballX)) { ballX -= ballDX; ballDX = -ballDX; } lastHitBlockIndex = index;

            //Y方向の移動
            //バーによる反射
            if ((ballY <= barY) && (barY < ballY + ballDY)) {
                var tmpX = (ballX * (ballY + ballDY - barY) + (ballX + ballDX) * (barY - ballY)) / ballDY;

                if ((barX <= tmpX) && (tmpX < barX + barWidth)) {
                    ballDY = - ballDY;
                    ballDX += (Math.random() - 0.5) * 1.0 + Math.min(5, Math.max(-5, barX - oldBarX)) * 0.1;
                    setPenetrateFlag(Math.abs(barX + barWidth / 2 - tmpX) < penetrateRegionWidth / 2);
                }
            }

            ballY += ballDY; index = getBlockIndexAtBall();

            if ((index != null) && (blockLives[index] > 0) && (lastHitBlockIndex != index)) {
                blockLives[index]--;
                if (blockLives[index] == 0) {
                    blockCount--;
                }

                blockElements[index].style.backgroundImage = blockImagePaths[blockLives[index]];
                blockElements[index].style.backgroundColor = blockColors[blockLives[index]];

                if (!penetrateFlag) {
                    ballY -= ballDY;
                    ballDY = -ballDY;
                }
            }

            if (ballY < 0) {
                ballY -= ballDY; ballDY = -ballDY;
            }

            if (stageHeight < ballY) {
                life--;
                setPhase(life > 0 ? PHASE_START : PHASE_GAMEOVER);
            }

            lastHitBlockIndex = index;


            setObjectPosition();

            oldBarX = barX;

            if (blockCount == 0) {
                setPhase(PHASE_CLEAR);
            }
        }

        function onTimerClear() {
            if (clearMessageCount > 0) {
                clearMessageCount--;
                if (clearMessageCount == 0) {
                    messageElement.style.visibility = 'hidden';
                }
            }
        }

        //初期化コード
        window.onload = init;



    </script>






</body>

</html>